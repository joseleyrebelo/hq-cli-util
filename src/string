#!/bin/zsh

source $HQ_ system
source $HQ_ utter
source $HQ_ exiter
source $HQ_ ensure

string__contains() {
	[[ $1 == *$2* ]] &&	return 0 || return 1
}

typeset -A string_is__queries
string_is__queries[num]="^[0-9]*$"
string_is__queries[alphanum]="^[a-zA-Z0-9]*$"
string_is__queries[alphanum_und]="^[a-zA-Z0-9_]*$"
string_is__queries[varname]=$string_is__queries[alphanum_und]
string_is__queries[alphanum_und_hyp]="^[a-zA-Z0-9_-]*$"

string_is() {
	local rgx_query=$string_is__queries[$1] 
	# @todo:refactor/
	ensure_not__empty "$rgx_query" "There's no string_is validator \"$1\""

	[[ $2 =~ $rgx_query ]] && return 0 || return 1
}

string__replace(){
	ensure__n_args 3
	ensure__variable $1

	echo ${(P)${1}//${2}/${3}}
}

string_isnt() {
	string_is $@ && return 1 || return 0
}

# @todo:refactor/assess - very limited implemetation
# - should return a split array instead
# - split by delimiter should be more than 2 parts 
# - create functions such as 
# - - string__split_count - returns amount of items split
# - - string__split_item - return item as per index arg provided; 
# - - !! - all functions accept a string to be splitted; acts differently if this 
# string is not provided.

string__split() {
	ensure__min_args 3
	local text=$1
	local delimiter=$2
	local part=$3
	# Is backwards flag enable the search for the splpit delimiter to start from 
	# the end of the string, last character backwards, instead of the first letter
  # onwards. 
	local is_backwards=false 
	[[ -n $4 ]] && is_backwards=$4 
	
	string__contains $1 $2 ||
		# @todo:evaluate - should it fail if it can't split a string ?
		return 1

	is__bigger $part 2 && 
		# @todo:refactor/improve 
		exiter "Error in string__split, there's only part 1 and 2."

	$is_backwards && 
	{
		is__equal $part 1 && 
			echo "${text%$delimiter*}" || 
			echo "${text##*$delimiter}" 
	} || { 
		is__equal $part 1 &&
			echo "${text%%$delimiter*}" ||
			echo "${text#*$delimiter}"
	}

	return 0
		
}



string__trim_post() {
  if [[ $# -ge 1 ]]; then
    local text=$1
    local search=" "
    [[ $2 ]] && search=$2
    local search_length=${#search}
    local text_length=${#text}
    local loop_needle=$((text_length - search_length))
    local cut_length=$text_length
    local keep_going=1
    while [[ $keep_going == 1 && $loop_needle -ge 0 ]]; do
      if [[ ${text:$loop_needle:$search_length} == $search ]]; then
        cut_length=$((loop_needle))
        loop_needle=$((loop_needle - search_length))
      else
        keep_going=0
      fi
    done
    echo ${text:0:$cut_length}
    return 1
  else
    system__missing_args
    return 0
  fi
}

# @todo - make use of zsh/bash string substitution 
string__trim_pre() {
	ensure__min_args 1
  local text=$1
  local search=" " && [[ $2 ]] && search=$2
  local search_length=${#search}
  local text_length=${#text}
  local loop_needle=0
  local cut_length=0
  local cut_needle=0
  local keep_going=1
  while [[ $keep_going == 1 && $loop_needle -ge 0 ]]; do
    if [[ ${text:$loop_needle:$search_length} == $search ]]; then
      loop_needle=$((loop_needle + search_length))
      cut_needle=$((loop_needle))
    else
      keep_going=0
    fi
  done
  cut_length=$((text_length - cut_needle))
  utter ${text:$cut_needle:$cut_length}
  return 0
}

string__trim() {
	ensure__min_args 1 $@
  local trim_pre=$(string__trim_pre "$1" $2)
  if [[ -z $trim_pre ]]; then
    utter $trim_pre
		return 1
	else
		utter $(string__trim_post "$trim_pre" $2)
		return 1
	fi
}

string__dequote() {
	ensure__min_args 1 $@
	local text=$1
	text="${text#\"}"
	text="${text%\"}"
	utter $text
	return 0
}

string__slice() {
	# @todo make it access pointer??
	
}





