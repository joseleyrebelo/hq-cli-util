#!/bin/zsh

# IS (1/2)

is_set (){
}

is_dir(){
	[[ -d $1 ]] && return 0 || return 1 
}


is_n_args() {
	# This is a readability and dry-helper function, it's not
	# optimized for performance. Approached from a bash utilitarian
	# priciple. Please note:
	# - The 1st argument is the size of args expected
	# - The remaining args are arbitrary; and ultimately represent 
	# the amount of variables this function will check against. Such
	# that it will be total of received args on this function call 
	# minus one.
	local args_n=$(( $# - 1 )) 
	# TODO - organize/continue documentation
	# - DOC $(( - in this instance runs an arbitrary operation and outputs
	# diretly, instead of direct to $?, or STDOUT 
	# - DOC $# - number of args 
	local target=$1 # $1 gets the target size
	(( args_n == target )) && return 0 || return 1
	# - DOC (( - Returns the logical result of the operation it wraps in
	# this instance.
}

is_min_args() {
	local target=$1
	local args_n=$(( $# - 1 ))
	[ $args_n -ge $1 ] && return 0 || return 1
}

is_args_n_range () {
	#TAIL - create this function to connect to importer requirment
	# - PRoceed to fix importer file to allow two args 
	# >> Perhaps you want a min type situation instead of a set range ??
	# - - The idea here seems to be to limit the max of args as a performance matter ?? Overkill ?
	# - -  This applies well to importer because it should inform the user of the importer if unnecessary args are added.
	# - inally this will allow importer to import misc/general to hqconf (requiring system__echo_or_not )
	# - this cause currently running "yarnlocal react-spots" in react-froms causes issues
}

# ISN'T - Negation of previos is_... functions 

isnt_n_args() {
	is_n_args "$@"; (( $? )) && return 1 || return 0
}

isnt_min_args() {
	is_min_args "$@"; (( $? )) && return 1 || return 0
}


