#!/bin/zsh

source $HQ_IMPORTER is-util
source $HQ_IMPORTER narrate


# Here _lr stands for last return ($?
ensure_lr() {(( $? )) && exiter $1}
exiter() {
	local stack_i=2
	local caller=$funcstack[$stack_i]
	local msg=""
	local ps=$2
	while [[ "$caller" == *"ensure_"* ]]; do
		caller_before1=$caller_before
		caller_before1=$caller_before
		caller_before=$caller
		((stack_i++))
		caller=$funcstack[$stack_i]
	done
	[ -z $caller ] && msg="[(root )/$caller]" || 
		[ -z $caller_before1 ] && msg="[$caller_before/$caller]" ||
			msg="[$caller_before1/$caller_before/$caller]"

	[ ! -z $ps ] && ps="\n- $ps"
	narrate $msg $1 $ps
	exit 1 
} 


ensure_dependency() {
  type $1 >/dev/null 2>&1 || {
		exiter "Aborting operation ('$1' is required but not installed)."
  }
}

ensure_n_args () {
	isnt_n_args $@; ensure_lr "Args(n) error"
}

ensure_min_args () {
	isnt_min_args $@; ensure_lr "Args(min) error" 
}

ensure_args_n_range () {
	isnt_args_n_range $@; ensure_lr "Args(range) error"
}				

ensure_file() {
	ensure_min_args 1 $@
	[ ! -f $1 ] && exiter $2 "Aborting ($1 isn't a file)" 
}

ensure_dir() {
	ensure_min_args 1 $@
	[ ! -d $1 ] && exiter $2 "Aborting, \"$1\" isn't a directory" 
}

error_handler() { echo $1 && exit 1 } 

# - ens...awn func should have an exit if empty  
ensure_dir_or_spawn () {
	ensure_min_args 1 "$@"
	# TODOc - Use of curly brackets to have or taking effect as per 
	# mkdir return instead of -d $1 logic.
  [ ! -d $1 ] && { mkdir -p $1 || exit 1 }
}

ensure_file_or_spawn () {
	ensure_min_args 1 "$@"
	[ ! -f $1 ] && { touch $1 || exit 1 } 
}

ensure_not_empty() {
	ensure_min_args 1 "$@"
	[ -z $1 ] && exiter "Aborting ($1 is an empty string)"
}

ensure_not_in_array() {	
	# TODO - ...
}

